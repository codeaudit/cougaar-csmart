<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <title>Specific Component Recipe</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000FF" vlink="#800080">

<h1>Component Insertion Recipe</h1>

A Component Insertion Recipe contains the following parameters:
    <h2>Component Fields</h2>
    <table>
	<tr>
	  <td><b>Name</b></td>
	  <td><b>Type</b></td>
	  <td><b>Range</b></td>
	</tr>
	<tr>
	  <td><a href="#TARGET_QUERY">Target Component Selection Query</a></td>
	  <td>String</td>
	  <td>recipeComponent query name</td>
	</tr>
	<tr>
	  <td><a href="#INSERTION_QUERY">Inserted Component Specification Query</a></td>
	  <td>String</td>
	  <td>recipeComponent query name</td>
	</tr>
	<tr>
	  <td><a href="#INSERTION_ARGS_QUERY">Inserted Component Arguments</a></td>
	  <td>String</td>
	  <td>recipeComponent query name</td>
	</tr>
    </table>  
<p>
  Components can be added to a society, such as a plugin in an agent,
  or a new binder. Component insertion recipes compute the components
  to be inserted and where by executing queries in the configuration
  database. There are three queries, described below, specifying the
  components to be modified, the components to be inserted and the
  arguments of the inserted components. All such queries come from
  CIP/configs/common/PopulateDb.q (for basic or example queries), or a
  file called "recipeQueries.q" for user defined queries (often built
  by copying queries from the other file, renaming them, and editing
  one or two values). This other file should be someplace on the
  Cougaar Config Path - for example, the directory from which CSMART
  is run, or CIP/configs/common.
</p>
<p>
  <a name="TARGET_QUERY"><h3>Target Component Selection Query</h3></a>
  This query lists the target components and should return
  COMPONENT_ALIB_ID values such as appear in the
  V4_ALIB_COMPONENT.COMPONENT_ALIB_ID column. It is not necessary for
  the ids to be distinct. The substitutions that are available during
  this first query are: :assembly_match: which has something like
  &quot;in ('assembly', 'assembly', ...)&quot; and should be used as
  &quot;... AND R.ASSEMBLY_ID :assembly_match;&quot; which would be
  true if the assembly_id is in the set of assemblies of the current
  experiment trial.
</p>
<p>
<a name="INSERTION_QUERY"><h3>Inserted Component Specification Query</h3></a>
  The second query is used to obtain descriptions of the components
  that are to be inserted. It is executed once for each target
  component. A row should be returned for each component to be
  inserted into the target component. Each returned row should be a
  triple consisting of: component name, component type, and class
  name. The number of components inserted equals the number of rows
  returned. The substitutions available consist of the following:
</p>
<blockquote>
  :component_name:<br>
  :component_lib_id:<br>
  :component_alib_id:<br>
  :component_category:<br>
  :component_class:<br>
  :insertion_point:<br>
  :description:<br>
</blockquote>
<p>
  These are all relative to the target component. So for example, if
  the target is an agent the insertion point would be
  Node.AgentManager.Agent
</p>
<p>
<a name="INSERTION_ARGS_QUERY"><h3>Inserted Component Arguments</h3></a>
  The third query is performed for each inserted component. Each row
  returned corresponds to a parameter of the component and consists of
  two parts: name and value. If both are non-null, the parameter is
  constructed by concatenating the string together with an
  &quot;=&quot; between them. If either is null, the other is used
  (without an &quot;=&quot;). The same substitutions are available,
  except they refer to the component being inserted.
</p>
</body>
</html>